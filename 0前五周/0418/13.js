/*
 * 所有的I都是全局下的，每一轮循环设置一个定时器（定时器属于异步操作：无需等待定时器执行），继续下一轮循环 => 定时器触发执行的时候，循环已经结束，全局的I=10
 * 
 * 10个定时器依次触发执行（此时循环肯定结束了），用到I都是全局的
 */
/* for (var i = 0; i < 10; i++) {
	setTimeout(() => {
		console.log(++i); //=>11 12 13 ...
	}, 1000);
} */

/* 决绝思路：定时器触发执行函数，让函数中的I别再是全局的即可 */
/* for (let i = 0; i < 10; i++) {
	// LET可以把每一轮循环都变为一个私有的块作用域（循环10次则创建10个私有的），每一个私有作用域中都有一个私有变量I，分别存储每一轮循环的索引信息
	setTimeout(() => {
		// 定时触发执行，用到的I一定是找对应的私有块作用域中的I
		console.log(i);
	}, 1000);
} */

/* for (let i = 0; i < 10; i++) {
	(function (i) {
		setTimeout(() => {
			console.log(i);
		}, 1000);
	})(i); //=>把每一轮循环全局I的值传递给私有上下文中的形参I
} */